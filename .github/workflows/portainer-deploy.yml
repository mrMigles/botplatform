name: Build and Deploy to Portainer

on:
  push:
    branches:
      - main
      - master
    tags:
      - '**'
  pull_request:
    branches:
      - '**'
  workflow_dispatch: {}

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: mrmigles/pakhombot

jobs:
  pr-docker-build:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine image tag
        run: |
          TAG="${GITHUB_HEAD_REF}"
          TAG="${TAG//\//_}"
          TAG="${TAG//\\/_}"
          echo "TAG=$TAG" >> "$GITHUB_ENV"

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}

  build-and-deploy:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Make Maven wrapper executable
        run: chmod +x mvnw

      - name: Build application
        run: ./mvnw -B -ntp package -DskipTests

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine image tag
        run: |
          REF="${GITHUB_REF}"
          if [[ "$REF" == refs/tags/* ]]; then
            TAG="${REF#refs/tags/}"
          elif [[ "$REF" == refs/heads/main || "$REF" == refs/heads/master ]]; then
            TAG="latest"
          else
            TAG="${REF#refs/heads/}"
            TAG="${TAG//\//_}"
            TAG="${TAG//\\/_}"
          fi
          echo "TAG=$TAG" >> "$GITHUB_ENV"

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}

      - name: Deploy stack via Portainer API
        env:
          PORTAINER_URL: ${{ secrets.PORTAINER_URL }}
          PORTAINER_USERNAME: ${{ secrets.PORTAINER_USERNAME }}
          PORTAINER_PASSWORD: ${{ secrets.PORTAINER_PASSWORD }}
          PORTAINER_STACK_ID: ${{ secrets.PORTAINER_STACK_ID }}
        run: |
          python - <<'PY'
          import json
          import os
          import sys
          from urllib import error, request

          def exit_with_http_details(exc: error.HTTPError) -> None:
              body = exc.read().decode(errors="replace") if exc.fp else ""
              sys.exit(f"HTTP {exc.code} when calling {exc.url}: {body}")

          url = os.environ.get("PORTAINER_URL")
          username = os.environ.get("PORTAINER_USERNAME")
          password = os.environ.get("PORTAINER_PASSWORD")
          stack_id = os.environ.get("PORTAINER_STACK_ID")
          if not all([url, username, password, stack_id]):
              sys.exit("Portainer secrets are not configured")

          base = url.rstrip("/")
          auth_request = request.Request(
              f"{base}/api/auth",
              data=json.dumps({"Username": username, "Password": password}).encode(),
              headers={"Content-Type": "application/json"},
          )
          try:
              with request.urlopen(auth_request) as resp:
                  token = json.loads(resp.read().decode()).get("jwt")
          except error.HTTPError as exc:
              exit_with_http_details(exc)
          except error.URLError as exc:
              sys.exit(f"Failed to reach Portainer auth endpoint: {exc.reason}")

          if not token:
              sys.exit("Failed to obtain Portainer JWT token")

          headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}

          # Get stack details (includes EndpointId)
          inspect_request = request.Request(f"{base}/api/stacks/{stack_id}", headers=headers)
          try:
              with request.urlopen(inspect_request) as resp:
                  stack = json.loads(resp.read().decode())
          except error.HTTPError as exc:
              exit_with_http_details(exc)
          endpoint_id = stack.get("EndpointId")
          if endpoint_id is None:
              sys.exit("Stack response missing EndpointId")

          # Get current stack file content
          file_request = request.Request(f"{base}/api/stacks/{stack_id}/file", headers=headers)
          try:
              with request.urlopen(file_request) as resp:
                  file_data = json.loads(resp.read().decode())
          except error.HTTPError as exc:
              exit_with_http_details(exc)
          stack_file_content = file_data.get("StackFileContent") or file_data.get("stackFileContent", "")
          env = file_data.get("Env") or file_data.get("env") or []

          # Redeploy via PUT (Portainer has no POST .../deploy endpoint)
          payload = {
              "endpointId": endpoint_id,
              "stackFileContent": stack_file_content,
              "env": env,
              "prune": True,
              "pullImage": True,
          }
          deploy_request = request.Request(
              f"{base}/api/stacks/{stack_id}",
              data=json.dumps(payload).encode(),
              headers=headers,
              method="PUT",
          )
          try:
              with request.urlopen(deploy_request) as resp:
                  print(f"Deploy response status: {resp.status}")
                  print(resp.read().decode())
          except error.HTTPError as exc:
              exit_with_http_details(exc)
          except error.URLError as exc:
              sys.exit(f"Failed to reach Portainer stack update endpoint: {exc.reason}")
          PY
